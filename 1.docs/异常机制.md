# Java异常机制

## 重点：

异常的目的？

```tex
处理程序的逻辑错误，运行时错误，网络错误等等
```



Java自带的异常的继承关系?

```tex
Throwable  -> Error/Exception
Exception -> IOException/RuntimeException
```

异常的分类？

```tex
非检查型异常:Error及RuntimeException的自异常类
检查型异常：除非检查型异常
```

检查型异常和非检查型异常？

如何捕获异常？

```tex
try{
	//可能抛出异常的代码
}catch(Exception e){
	//处理
}
```

可以同时捕获多种类型的异常? 可以

finally字句都会被执行？不论是否抛出异常finally语句都会执行

try语句可以只有finally语句? 可以

try-with-resource语句?

```tex
```



<br/>

在理想的世界中，用户的输入都是正确的。例如：选择打开的文件一定存在等等。  
现实世界中，却充满了不良的数据和有问题的代码，Java程序设计语言处理这些问题的机制，就是Java异常处理机制。  

在测试期间，需要运行大量的检查以确保程序操作的正确性。然而这些检查非常耗时，在测试完成之后没有必要保留。如果在生产级别代码中来手动的删除，在测试环节  
的时候再手动添加，这样会非常的繁琐。因此Java出现的断言机制。  

当程序发生错误时，并不总是能够与用户或终端进行通信。此时，我们可能希望记录出现的问题，已备日后进行分析。这就出现了Java的日志框架技术。  

总结来说：
1. 异常机制用于处理程序中的一些错误
2. 断言机制用于在测试程序与生产时的程序能方便添加/移除一些检查的机制。
3. 日志框架是为了保存系统信息，方便查看。

## 异常机制
Java中的所有异常对象都派生自Throwable类的一个类实例。如果Java中自带的异常类不能满足当前Java程序的要求，可以创建自己的异常类。  

Java中自带的异常继承关系图如图:

```tex
                                  Throwable(class)
                       Error(class)              Exception(class)
                       ...              IOException(class)    RuntimeException(class)
                                        ...            		  ....
```

```
异常的分类：
Threowable:顶级异常基类。
Error:描述Java运行时系统的内部错误和资源耗尽错误。普通的Java程序不应该抛出该类异常。
Exception:
	IOException:程序本身没问题，但是像I/O错误这类问题引发的异常。
		试图超越文本末尾继续读取数据
		视图打开一个不存在的文件
		...
	RuntimeException:由编程错误导致的异常。
		错误的强制转换异常
		数组访问越界
		访问Null指针
		...

检查型与非检查型异常的分类：
非检查型异常：派生于Error和RuntimeException的异常。(编译器不要求必须为异常提供异常处理器)
检查型异常：除非检查型异常。(编译器将检查是否为所有的检查型异常提供异常处理器)
```

